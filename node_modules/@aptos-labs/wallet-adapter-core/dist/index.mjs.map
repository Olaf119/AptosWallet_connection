{"version":3,"sources":["../src/WalletCore.ts","../src/constants.ts","../src/error/index.ts","../src/utils/scopePollingDetectionStrategy.ts","../src/utils/localStorage.ts"],"sourcesContent":["import { HexString, Types } from \"aptos\";\nimport EventEmitter from \"eventemitter3\";\nimport nacl from \"tweetnacl\";\nimport { Buffer } from \"buffer\";\n\nimport { WalletReadyState } from \"./constants\";\nimport {\n  WalletAccountChangeError,\n  WalletAccountError,\n  WalletConnectionError,\n  WalletDisconnectionError,\n  WalletGetNetworkError,\n  WalletNetworkChangeError,\n  WalletNotConnectedError,\n  WalletNotReadyError,\n  WalletNotSelectedError,\n  WalletNotSupportedMethod,\n  WalletSignAndSubmitMessageError,\n  WalletSignMessageAndVerifyError,\n  WalletSignMessageError,\n  WalletSignTransactionError,\n} from \"./error\";\nimport {\n  AccountInfo,\n  NetworkInfo,\n  WalletName,\n  SignMessagePayload,\n  SignMessageResponse,\n  Wallet,\n  WalletInfo,\n  WalletCoreEvents,\n} from \"./types\";\nimport {\n  removeLocalStorage,\n  setLocalStorage,\n  scopePollingDetectionStrategy,\n} from \"./utils\";\n\nexport class WalletCore extends EventEmitter<WalletCoreEvents> {\n  private _wallets: Wallet[] = [];\n  private _wallet: Wallet | null = null;\n  private _account: AccountInfo | null = null;\n  private _network: NetworkInfo | null = null;\n\n  private _connecting: boolean = false;\n  private _connected: boolean = false;\n\n  constructor(plugins: Wallet[]) {\n    super();\n    this._wallets = plugins;\n    this.scopePollingDetectionStrategy();\n  }\n\n  private scopePollingDetectionStrategy() {\n    this._wallets?.forEach((wallet: Wallet) => {\n      if (!wallet.readyState) {\n        wallet.readyState =\n          typeof window === \"undefined\" || typeof document === \"undefined\"\n            ? WalletReadyState.Unsupported\n            : WalletReadyState.NotDetected;\n      }\n      if (typeof window !== \"undefined\") {\n        scopePollingDetectionStrategy(() => {\n          const providerName = wallet.providerName || wallet.name.toLowerCase();\n          if (Object.keys(window).includes(providerName)) {\n            wallet.readyState = WalletReadyState.Installed;\n            wallet.provider = window[providerName as any];\n            this.emit(\"readyStateChange\", wallet);\n            return true;\n          }\n          return false;\n        });\n      }\n    });\n  }\n\n  private doesWalletExist(): boolean | WalletNotConnectedError {\n    if (!this._connected || this._connecting || !this._wallet)\n      throw new WalletNotConnectedError().name;\n    if (\n      !(\n        this._wallet.readyState === WalletReadyState.Loadable ||\n        this._wallet.readyState === WalletReadyState.Installed\n      )\n    )\n      throw new WalletNotReadyError().name;\n    return true;\n  }\n\n  private clearData() {\n    this._connected = false;\n    this.setWallet(null);\n    this.setAccount(null);\n    this.setNetwork(null);\n    removeLocalStorage();\n  }\n\n  setWallet(wallet: Wallet | null) {\n    this._wallet = wallet;\n  }\n\n  setAccount(account: AccountInfo | null) {\n    this._account = account;\n  }\n\n  setNetwork(network: NetworkInfo | null) {\n    this._network = network;\n  }\n\n  isConnected(): boolean {\n    return this._connected;\n  }\n\n  get wallets(): Wallet[] {\n    return this._wallets;\n  }\n\n  /**\n   * Getter for the current connected wallet\n   * @return wallet info\n   * @throws WalletNotSelectedError\n   */\n  get wallet(): WalletInfo | null {\n    try {\n      if (!this._wallet) return null;\n      return {\n        name: this._wallet.name,\n        icon: this._wallet.icon,\n        url: this._wallet.url,\n      };\n    } catch (error: any) {\n      throw new WalletNotSelectedError(error).message;\n    }\n  }\n\n  /**\n   * Getter for the current connected account\n   * @return account info\n   * @throws WalletAccountError\n   */\n  get account(): AccountInfo | null {\n    try {\n      return this._account;\n    } catch (error: any) {\n      throw new WalletAccountError(error).message;\n    }\n  }\n\n  /**\n   * Getter for the current wallet network\n   * @return network info\n   * @throws WalletGetNetworkError\n   */\n  get network(): NetworkInfo | null {\n    try {\n      return this._network;\n    } catch (error: any) {\n      throw new WalletGetNetworkError(error).message;\n    }\n  }\n\n  /** \n  Connects a wallet to the app. If a wallet is already connected,\n  we first disconnect the current connected wallet and then connect the selected wallet.\n  On connect success, we set the current account and the network, and keeping the selected wallet\n  name in LocalStorage to support autoConnect function.\n\n  @param walletName. The wallet name we want to connect as a WalletName type.\n  @emit emits \"connect\" event\n  @throws WalletConnectionError\n  */\n  async connect(walletName: WalletName): Promise<void> {\n    try {\n      const selectedWallet = this._wallets?.find(\n        (wallet: Wallet) => wallet.name === walletName\n      );\n\n      if (\n        !selectedWallet ||\n        (selectedWallet.readyState !== WalletReadyState.Installed &&\n          selectedWallet.readyState !== WalletReadyState.Loadable)\n      ) {\n        return;\n      }\n\n      if (this._connected) {\n        await this.disconnect();\n      }\n      this._connecting = true;\n      this.setWallet(selectedWallet);\n      const account = await selectedWallet.connect();\n      this.setAccount({ ...account });\n      const network = await selectedWallet.network();\n      this.setNetwork({ ...network });\n      setLocalStorage(selectedWallet.name);\n      this._connected = true;\n      this.emit(\"connect\", account);\n    } catch (error: any) {\n      this.clearData();\n      throw new WalletConnectionError(error).message;\n    } finally {\n      this._connecting = false;\n    }\n  }\n\n  /** \n  Disconnect the exisitng wallet. On success, we clear the \n  current account, current network and LocalStorage data.\n  @emit emits \"disconnect\" event\n  @throws WalletDisconnectionError\n  */\n  async disconnect(): Promise<void> {\n    try {\n      this.doesWalletExist();\n      await this._wallet?.disconnect();\n      this.clearData();\n      this.emit(\"disconnect\");\n    } catch (error: any) {\n      throw new WalletDisconnectionError(error).message;\n    }\n  }\n\n  /** \n  Sign and submit transaction to chain.\n  @param transaction\n  @return response from the wallet's signAndSubmitTransaction function\n  @throws WalletSignAndSubmitMessageError\n  */\n  async signAndSubmitTransaction(\n    transaction: Types.TransactionPayload\n  ): Promise<any> {\n    try {\n      this.doesWalletExist();\n      const response = await this._wallet?.signAndSubmitTransaction(\n        transaction\n      );\n      return response;\n    } catch (error: any) {\n      const errMsg =\n        typeof error == \"object\" && \"message\" in error ? error.message : error;\n      throw new WalletSignAndSubmitMessageError(errMsg).message;\n    }\n  }\n\n  /** \n  Sign transaction (doesnt submit to chain).\n  @param transaction\n  @return response from the wallet's signTransaction function\n  @throws WalletSignTransactionError\n  */\n  async signTransaction(\n    transaction: Types.TransactionPayload\n  ): Promise<Uint8Array | null> {\n    if (this._wallet && !(\"signTransaction\" in this._wallet)) {\n      throw new WalletNotSupportedMethod(\n        `Sign Transaction is not supported by ${this.wallet?.name}`\n      ).message;\n    }\n\n    try {\n      this.doesWalletExist();\n      const response = await (this._wallet as any).signTransaction(transaction);\n      return response;\n    } catch (error: any) {\n      const errMsg =\n        typeof error == \"object\" && \"message\" in error ? error.message : error;\n      throw new WalletSignTransactionError(errMsg).message;\n    }\n  }\n\n  /** \n  Sign message (doesnt submit to chain).\n  @param message\n  @return response from the wallet's signMessage function\n  @throws WalletSignMessageError\n  */\n  async signMessage(\n    message: SignMessagePayload\n  ): Promise<SignMessageResponse | null> {\n    try {\n      this.doesWalletExist();\n      if (!this._wallet) return null;\n      const response = await this._wallet?.signMessage(message);\n      return response;\n    } catch (error: any) {\n      const errMsg =\n        typeof error == \"object\" && \"message\" in error ? error.message : error;\n      throw new WalletSignMessageError(errMsg).message;\n    }\n  }\n\n  /** \n  Event for when account has changed on the wallet\n  @return the new account info\n  @throws WalletAccountChangeError\n  */\n  async onAccountChange(): Promise<void> {\n    try {\n      this.doesWalletExist();\n      await this._wallet?.onAccountChange((data: AccountInfo) => {\n        this.setAccount({ ...data });\n        this.emit(\"accountChange\", this._account);\n      });\n    } catch (error: any) {\n      const errMsg =\n        typeof error == \"object\" && \"message\" in error ? error.message : error;\n      throw new WalletAccountChangeError(errMsg).message;\n    }\n  }\n\n  /** \n  Event for when network has changed on the wallet\n  @return the new network info\n  @throws WalletNetworkChangeError\n  */\n  async onNetworkChange(): Promise<void> {\n    try {\n      this.doesWalletExist();\n      await this._wallet?.onNetworkChange((data: NetworkInfo) => {\n        this.setNetwork({ ...data });\n        this.emit(\"networkChange\", this._network);\n      });\n    } catch (error: any) {\n      const errMsg =\n        typeof error == \"object\" && \"message\" in error ? error.message : error;\n      throw new WalletNetworkChangeError(errMsg).message;\n    }\n  }\n\n  async signMessageAndVerify(message: SignMessagePayload): Promise<boolean> {\n    try {\n      this.doesWalletExist();\n      if (!this._account) throw new Error(\"No account found!\");\n      const response = await this._wallet?.signMessage(message);\n      if (!response)\n        throw new WalletSignMessageAndVerifyError(\"Failed to sign a message\")\n          .message;\n      // Verify that the bytes were signed using the private key that matches the known public key\n      let verified = false;\n      if (Array.isArray(response.signature)) {\n        // multi sig wallets\n        const { fullMessage, signature, bitmap } = response;\n        if (bitmap) {\n          const minKeysRequired = this._account.minKeysRequired as number;\n          if (signature.length < minKeysRequired) {\n            verified = false;\n          } else {\n            // Getting an array which marks the keys signing the message with 1, while marking 0 for the keys not being used.\n            const bits = Array.from(bitmap).flatMap((n) =>\n              Array.from({ length: 8 }).map((_, i) => (n >> i) & 1)\n            );\n            // Filter out indexes of the keys we need\n            const index = bits.map((_, i) => i).filter((i) => bits[i]);\n\n            const publicKeys = this._account.publicKey as string[];\n            const matchedPublicKeys = publicKeys.filter(\n              (_: string, i: number) => index.includes(i)\n            );\n\n            verified = true;\n            for (let i = 0; i < signature.length; i++) {\n              const isSigVerified = nacl.sign.detached.verify(\n                Buffer.from(fullMessage),\n                Buffer.from(signature[i], \"hex\"),\n                Buffer.from(matchedPublicKeys[i], \"hex\")\n              ); // `isSigVerified` should be `true` for every signature\n\n              if (!isSigVerified) {\n                verified = false;\n                break;\n              }\n            }\n          }\n        } else {\n          throw new WalletSignMessageAndVerifyError(\"Failed to get a bitmap\")\n            .message;\n        }\n      } else {\n        // single sig wallets\n        // support for when address doesnt have hex prefix (0x)\n        const currentAccountPublicKey = new HexString(\n          this._account.publicKey as string\n        );\n        // support for when address doesnt have hex prefix (0x)\n        const signature = new HexString(response.signature);\n        verified = nacl.sign.detached.verify(\n          Buffer.from(response.fullMessage),\n          Buffer.from(signature.noPrefix(), \"hex\"),\n          Buffer.from(currentAccountPublicKey.noPrefix(), \"hex\")\n        );\n      }\n      return verified;\n    } catch (error: any) {\n      const errMsg =\n        typeof error == \"object\" && \"message\" in error ? error.message : error;\n      throw new WalletSignMessageAndVerifyError(errMsg).message;\n    }\n  }\n}\n","export enum WalletReadyState {\n  /**\n   * User-installable wallets can typically be detected by scanning for an API\n   * that they've injected into the global context. If such an API is present,\n   * we consider the wallet to have been installed.\n   */\n  Installed = \"Installed\",\n  NotDetected = \"NotDetected\",\n  /**\n   * Loadable wallets are always available to you. Since you can load them at\n   * any time, it's meaningless to say that they have been detected.\n   */\n  Loadable = \"Loadable\",\n  /**\n   * If a wallet is not supported on a given platform (eg. server-rendering, or\n   * mobile) then it will stay in the `Unsupported` state.\n   */\n  Unsupported = \"Unsupported\",\n}\n\nexport enum NetworkName {\n  Mainnet = \"mainnet\",\n  Testnet = \"testnet\",\n  Devnet = \"devnet\",\n}\n","export class WalletError extends Error {\n  public error: any;\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(message?: string, error?: any) {\n    super(message);\n    this.error = error;\n  }\n}\n\nexport class WalletNotSelectedError extends WalletError {\n  name = \"WalletNotSelectedError\";\n}\n\nexport class WalletNotReadyError extends WalletError {\n  name = \"WalletNotReadyError\";\n}\n\nexport class WalletLoadError extends WalletError {\n  name = \"WalletLoadError\";\n}\n\nexport class WalletConfigError extends WalletError {\n  name = \"WalletConfigError\";\n}\n\nexport class WalletConnectionError extends WalletError {\n  name = \"WalletConnectionError\";\n}\n\nexport class WalletDisconnectedError extends WalletError {\n  name = \"WalletDisconnectedError\";\n}\n\nexport class WalletDisconnectionError extends WalletError {\n  name = \"WalletDisconnectionError\";\n}\n\nexport class WalletAccountError extends WalletError {\n  name = \"WalletAccountError\";\n}\nexport class WalletGetNetworkError extends WalletError {\n  name = \"WalletGetNetworkError\";\n}\n\nexport class WalletAccountChangeError extends WalletError {\n  name = \"WalletAccountChangeError\";\n}\n\nexport class WalletNetworkChangeError extends WalletError {\n  name = \"WalletNetworkChangeError\";\n}\n\nexport class WalletPublicKeyError extends WalletError {\n  name = \"WalletPublicKeyError\";\n}\n\nexport class WalletKeypairError extends WalletError {\n  name = \"WalletKeypairError\";\n}\n\nexport class WalletNotConnectedError extends WalletError {\n  name = \"WalletNotConnectedError\";\n}\n\nexport class WalletSendTransactionError extends WalletError {\n  name = \"WalletSendTransactionError\";\n}\n\nexport class WalletSignMessageError extends WalletError {\n  name = \"WalletSignMessageError\";\n}\n\nexport class WalletSignMessageAndVerifyError extends WalletError {\n  name = \"WalletSignMessageAndVerifyError\";\n}\n\nexport class WalletSignAndSubmitMessageError extends WalletError {\n  name = \"WalletSignAndSubmitMessageError\";\n}\n\nexport class WalletSignTransactionError extends WalletError {\n  name = \"WalletSignTransactionError\";\n}\n\nexport class WalletTimeoutError extends WalletError {\n  name = \"WalletTimeoutError\";\n}\n\nexport class WalletWindowBlockedError extends WalletError {\n  name = \"WalletWindowBlockedError\";\n}\n\nexport class WalletWindowClosedError extends WalletError {\n  name = \"WalletWindowClosedError\";\n}\n\nexport class WalletResponseError extends WalletError {\n  name = \"WalletResponseError\";\n}\n\nexport class WalletNotSupportedMethod extends WalletError {\n  name = \"WalletNotSupportedMethod\";\n}\n","export function scopePollingDetectionStrategy(detect: () => boolean): void {\n  // Early return when server-side rendering\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") return;\n\n  const disposers: (() => void)[] = [];\n\n  function detectAndDispose() {\n    const detected = detect();\n    if (detected) {\n      for (const dispose of disposers) {\n        dispose();\n      }\n    }\n  }\n\n  // Strategy #1: Try detecting every second.\n  const interval =\n    // TODO: #334 Replace with idle callback strategy.\n    setInterval(detectAndDispose, 1000);\n  disposers.push(() => clearInterval(interval));\n\n  // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n  if (\n    // Implies that `DOMContentLoaded` has not yet fired.\n    document.readyState === \"loading\"\n  ) {\n    document.addEventListener(\"DOMContentLoaded\", detectAndDispose, {\n      once: true,\n    });\n    disposers.push(() =>\n      document.removeEventListener(\"DOMContentLoaded\", detectAndDispose)\n    );\n  }\n\n  // Strategy #3: Detect after the `window` has fully loaded.\n  if (\n    // If the `complete` state has been reached, we're too late.\n    document.readyState !== \"complete\"\n  ) {\n    window.addEventListener(\"load\", detectAndDispose, { once: true });\n    disposers.push(() => window.removeEventListener(\"load\", detectAndDispose));\n  }\n\n  // Strategy #4: Detect synchronously, now.\n  detectAndDispose();\n}\n","import { WalletName } from \"../types\";\n\nconst LOCAL_STORAGE_ITEM_KEY = \"AptosWalletName\";\n\nexport function setLocalStorage(walletName: WalletName) {\n  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);\n}\n\nexport function removeLocalStorage() {\n  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);\n}\n\nexport function getLocalStorage() {\n  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);\n}\n"],"mappings":"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","names":["WalletReadyState","NetworkName"]}